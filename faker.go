package zntfaker

import (
	crand "crypto/rand"
	"encoding/base64"
	"fmt"
	"io"
	"math/rand"
	"net"
	"strconv"
	"strings"
	"time"
)

// ------------------ GLOBAL VARIABLES -------------------

var (
	maleFirstNames = []string{
		"Александр", "Дмитрий", "Иван", "Сергей", "Андрей", "Максим", "Алексей", "Никита", "Роман", "Кирилл",
		"Павел", "Михаил", "Егор", "Матвей", "Арсений", "Владимир", "Тимофей", "Ярослав", "Станислав", "Григорий",
		"Николай", "Даниил", "Константин", "Илья", "Вадим", "Федор", "Антон", "Виктор", "Олег", "Тимур",
		"Вячеслав", "Богдан", "Леонид", "Денис", "Родион", "Артур", "Виталий", "Юрий", "Тихон", "Марсель",
		"Прохор", "Игорь", "Савелий", "Геннадий", "Рустам", "Эмиль", "Рамиль", "Марат", "Артём", "Евгений",
		"Валерий", "Захар", "Трофим", "Анатолий", "Тарас", "Арсен", "Глеб", "Роман", "Елисей", "Аркадий",
		"Пётр", "Лука", "Назар", "Семён", "Сергей", "Ростислав", "Мирон", "Ян", "Виктор", "Давид",
		"Радий", "Амир", "Валентин", "Эдуард", "Мирослав", "Эмиль", "Адриян", "Василий", "Гордей", "Ефим",
		"Богдан", "Лев", "Михаил", "Горячий", "Ярослав", "Клим", "Филипп", "Евдоким", "Нестор", "Владислав",
		"Тимофей", "Елисей", "Демид", "Борис", "Платон", "Аким", "Роман", "Владлен", "Анатолий", "Дамир",
		"Сава", "Эрик", "Илларион", "Юлиан", "Савва", "Альберт", "Еремей", "Данила", "Никита", "Герман",
	}

	femaleFirstNames = []string{
		"Анна", "Мария", "Екатерина", "Ольга", "Татьяна", "Наталья", "Алина", "Ксения", "Полина", "Виктория",
		"Дарья", "Ирина", "Анастасия", "Вероника", "Арина", "Людмила", "Вера", "Жанна", "Софья", "Елизавета",
		"Юлия", "Олеся", "Кира", "Надежда", "Марина", "Евгения", "Алёна", "Снежана", "Лариса", "Таисия",
		"Любава", "Элина", "Кристина", "Ева", "Аделина", "Милана", "Яна", "Лилия", "Нина", "Карина",
		"Диана", "Ангелина", "Светлана", "Клавдия", "Инна", "Регина", "Эмилия", "Зоя", "Надежда", "Ярослава",
		"Валерия", "Сабина", "Эльвира", "Лидия", "Юлиана", "Евдокия", "Маргарита", "Наталия", "Валентина", "Любовь",
		"София", "Мадина", "Агата", "Капитолина", "Анжелика", "Марта", "Лилия", "Злата", "Юлианна", "Каролина",
		"Люция", "Сусанна", "Владислава", "Дарина", "Эльза", "Полина", "Верена", "Марианна", "Алиса", "Виктория",
		"Антонина", "Ника", "Элина", "Галина", "Серафима", "Эвелина", "Роксана", "Алия", "Нелли", "Лиана",
		"Камилла", "Таисия", "Фаина", "Лея", "Аурелия", "Арина", "Мария", "Ксения", "Тамара", "Валерия",
		"Оксана", "Эльмира", "Алиса", "Дина", "Милена", "Жасмин", "Ефросинья", "Людмила", "Анабель", "Василиса",
	}

	lastNames = []string{
		"Иванов", "Смирнов", "Кузнецов", "Попов", "Васильев", "Петров", "Соколов", "Михайлов", "Новиков", "Фёдоров",
		"Морозов", "Волков", "Алексеев", "Лебедев", "Семенов", "Егоров", "Павлов", "Козлов", "Степанов", "Николаев",
		"Орлов", "Андреев", "Макаров", "Никитин", "Захаров", "Романов", "Белов", "Качалов", "Карпов", "Богданов",
		"Белоусов", "Сорокин", "Матвеев", "Емельянов", "Исаев", "Поляков", "Виноградов", "Крылов", "Ковалев", "Жуков",
		"Соколовский", "Тихонов", "Щербаков", "Ларионов", "Фролов", "Борисов", "Кондратьев", "Афиногенов", "Рябов", "Логинов",
		"Ширяев", "Пономарев", "Комаров", "Киселёв", "Трофимов", "Кудрявцев", "Максимов", "Осипов", "Титов", "Баранов",
		"Булаев", "Карасёв", "Юдин", "Александров", "Чернов", "Мельников", "Бирюков", "Архипов", "Коновалов", "Прохоров",
		"Бобров", "Крылов", "Паутин", "Южин", "Дорофеев", "Горбунов", "Лобанов", "Лукин", "Лебедев", "Шестаков",
		"Ефимов", "Носов", "Брагин", "Устинов", "Савельев", "Игнатьев", "Караулов", "Юрьев", "Шубин", "Калинин",
	}

	maleMiddleNames = []string{
		"Александрович", "Иванович", "Дмитриевич", "Сергеевич", "Алексеевич", "Юрьевич", "Павлович", "Михайлович",
		"Владимирович", "Константинович", "Григорьевич", "Егорович", "Матвеевич", "Федорович", "Андреевич", "Никитич",
		"Васильевич", "Аркадьевич", "Леонидович", "Тимофеевич", "Олегович", "Вячеславович", "Романович", "Пётрович",
		"Тарасович", "Богданович", "Ярославович", "Игоревич", "Максимович", "Ростиславович", "Львович", "Родионович", "Захарович", "Трофимович",
		"Виталиевич", "Якубович", "Сергеевич", "Евгеньевич", "Николаевич", "Миронович", "Лукич", "Мартынович", "Арсенович", "Борисович",
		"Рустамович", "Владленович", "Валериевич", "Филиппович", "Радионович", "Игнатевич", "Русланович", "Платонович", "Глебович", "Даниилович",
		"Мирославович", "Эдуардович", "Амирович", "Анатольевич", "Раян", "Семенович", "Прокофьевич", "Ефимович", "Прохорович", "Тимурович",
		"Кириллович", "Давидович", "Артурович", "Ильич", "Юлианович", "Семенович", "Назарович", "Гордеев", "Венедиктович", "Викторович",
		"Матвеевич", "Родионович", "Валентинович", "Елисейевич", "Брониславович", "Альбертович", "Ярославич", "Аркадьевич", "Эмильевич", "Святославович",
		"Демидович", "Кириллович", "Ростиславович", "Валерьевич", "Эммануилович", "Эльдарович", "Гордеевич", "Романолович", "Данилович", "Глебович",
	}

	femaleMiddleNames = []string{
		"Александровна", "Ивановна", "Дмитриевна", "Сергеевна", "Алексеевна", "Юрьевна", "Павловна", "Михайловна",
		"Владимировна", "Константиновна", "Григорьевна", "Егоровна", "Матвеевна", "Федоровна", "Андреевна", "Никитична",
		"Васильевна", "Аркадьевна", "Леонидовна", "Тимофеевна", "Олеговна", "Вячеславовна", "Романовна", "Пётровна",
		"Тарасовна", "Богдановна", "Ярославовна", "Игоревна", "Максимовна", "Ростиславовна", "Львовна", "Родионовна", "Захаровна", "Трофимовна",
		"Виталиевна", "Якубовна", "Сергеевна", "Евгеньевна", "Николаевна", "Мироновна", "Лукична", "Мартыновна", "Арсеновна", "Борисовна",
		"Рустамовна", "Владленовна", "Валериевна", "Филипповна", "Радионовна", "Игнатевна", "Руслановна", "Платоновна", "Глебовна", "Данииловна",
		"Мирославовна", "Эдуардовна", "Амировна", "Анатольевна", "Тимуровна", "Кирилловна", "Давидовна", "Артуровна", "Ильинична", "Юлиановна",
		"Семеновна", "Назаровна", "Гордеевна", "Венедиктовна", "Викторовна", "Елисейевна", "Брониславовна", "Альбертовна", "Ярославна", "Аркадьевна",
		"Эмильевна", "Святославовна", "Демидовна", "Кирилловна", "Ростиславовна", "Валерьевна", "Эммануиловна", "Эльдаровна", "Гордеевна", "Романоловна",
	}
)

var letters = []byte("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
var emailTLDs = []string{"ru", "com", "org", "net", "zenit.ru"}

// ------------------ Faker -------------------

// Faker — объект генератора фейковых данных
type Faker struct {
	rng *rand.Rand
}

// New создаёт новый инстанс Faker с уникальным seed
func New() *Faker {
	return &Faker{
		rng: rand.New(rand.NewSource(time.Now().UnixNano())),
	}
}

// Numerify заменяет все '#' в шаблоне случайными цифрами
func (f *Faker) Numerify(template string) string {
	var result strings.Builder
	for _, c := range template {
		if c == '#' {
			result.WriteByte(byte(f.rng.Intn(10) + '0'))
		} else {
			result.WriteRune(c)
		}
	}
	return result.String()
}

// ------------------ NAMES -------------------

// pickGender возвращает "m" или "f".
// Если передан пустой или некорректный пол, выбирает случайно.
func (f *Faker) pickGender(gender string) string {
	if gender != "m" && gender != "f" {
		if f.rng.Intn(2) == 0 {
			return "m"
		}
		return "f"
	}
	return gender
}

func (f *Faker) FirstName(gender string) string {
	gender = f.pickGender(gender)
	if gender == "m" {
		return maleFirstNames[f.rng.Intn(len(maleFirstNames))]
	}
	return femaleFirstNames[f.rng.Intn(len(femaleFirstNames))]
}

func (f *Faker) MiddleName(gender string) string {
	gender = f.pickGender(gender)
	if gender == "m" {
		return maleMiddleNames[f.rng.Intn(len(maleMiddleNames))]
	}
	return femaleMiddleNames[f.rng.Intn(len(femaleMiddleNames))]
}

func (f *Faker) LastName(gender string) string {
	gender = f.pickGender(gender)
	ret := lastNames[f.rng.Intn(len(lastNames))]

	if gender == "f" {
		return ret + "а"
	}
	return ret
}

// Person возвращает полное ФИО и отдельно фамилию, имя и отчество.
// gender: "m" - мужчина, "f" - женщина, "" - случайно
func (f *Faker) Person(gender string) (fullName, lastName, firstName, middleName string) {
	gender = f.pickGender(gender)
	lastName = f.LastName(gender)
	firstName = f.FirstName(gender)
	middleName = f.MiddleName(gender)
	fullName = fmt.Sprintf("%s %s %s", lastName, firstName, middleName)
	return
}

// ------------------ INT & STRING -------------------

func (f *Faker) Int(min, max int) int {
	return f.rng.Intn(max-min+1) + min
}

func (f *Faker) String(min, max int) string {
	length := f.Int(min, max)
	s := make([]byte, length) // []byte вместо []rune
	for i := range s {
		s[i] = letters[f.rng.Intn(len(letters))]
	}
	return string(s)
}

func (f *Faker) StringLength(old string) string {
	length := len([]rune(old))
	return f.String(length, length)
}

// ------------------ INN & OGRN -------------------

func rndNumber(rng *rand.Rand, length int) []int {
	var number []int
	for i := 0; i < length; i++ {
		number = append(number, rng.Intn(10))
	}
	return number
}

func (f *Faker) PersonalInn() string {
	n := rndNumber(f.rng, 10)
	n = append(n,
		((n[0]*7+n[1]*2+n[2]*4+n[3]*10+n[4]*3+n[5]*5+n[6]*9+n[7]*4+n[8]*6+n[9]*8)%11)%10)
	n = append(n,
		((n[0]*3+n[1]*7+n[2]*2+n[3]*4+n[4]*10+n[5]*3+n[6]*5+n[7]*9+n[8]*4+n[9]*6+n[10]*8)%11)%10)

	var ids []string
	for _, i := range n {
		ids = append(ids, strconv.Itoa(i))
	}

	return strings.Join(ids, "")
}

func (f *Faker) CompanyInn() string {
	n := rndNumber(f.rng, 9)
	n = append([]int{0}, n...)
	n = append(n,
		((2*n[1]+4*n[2]+10*n[3]+3*n[4]+5*n[5]+9*n[6]+4*n[7]+6*n[8]+8*n[9])%11)%10)
	n = n[1:] // удаляем первый элемент
	var ids []string
	for _, i := range n {
		ids = append(ids, strconv.Itoa(i))
	}
	return strings.Join(ids, "")
}

func (f *Faker) CompanyOgrn() string {
	ogrnStr := "1"
	yearNow := time.Now().Year()
	ogrnStr += fmt.Sprintf("%02d", (f.rng.Intn(yearNow-1995)+1995)%100)
	ogrnStr += fmt.Sprintf("%02d", f.rng.Intn(1089-1001)+1001%100)
	ogrnStr += "00"
	ogrnStr += fmt.Sprintf("%05d", f.rng.Intn(99999-10001)+10001)
	control, _ := strconv.Atoi(ogrnStr)
	control = control % 11
	if control == 10 {
		control = 0
	}
	return ogrnStr + fmt.Sprintf("%d", control)
}

// ------------------ PHONE & EMAIL -------------------

func (f *Faker) E164PhoneNumber() string {
	return f.Numerify("+7888#######")
}

func (f *Faker) PhoneBeauty() string {
	return f.Numerify("+7 (888) ###-##-##")
}

func (f *Faker) PhoneMSISDN() string {
	return f.Numerify("7888#######")
}

func (f *Faker) PhoneBeautyNoCountry() string {
	return f.Numerify("(888) ###-##-##")
}

func (f *Faker) Email() string {
	localPart := f.String(3, 7) + "unface" + f.String(3, 7)
	domain := f.String(3, 7) + "unface" + f.String(3, 7)
	tld := emailTLDs[f.rng.Intn(len(emailTLDs))]
	return fmt.Sprintf("%s@%s.%s", localPart, domain, tld)
}

// ------------------ HASH & ENCODED -------------------

func (f *Faker) Base64UrlSafe(n int) string {
	if n <= 0 {
		return ""
	}
	b := make([]byte, n)
	_, _ = io.ReadFull(crand.Reader, b)

	// кодируем в URL-safe Base64 с padding
	return base64.URLEncoding.EncodeToString(b)
}

// принимает длину и формируется base64UrlSafe
// если n не кратно 4, то длина округляется вверх до кратного 4
func (f *Faker) Base64(n int) string {
	if n <= 0 {
		return ""
	}
	// округляем длину до кратной 4
	rounded := ((n + 3) / 4) * 4
	byteLen := rounded * 3 / 4

	b := make([]byte, byteLen)
	_, _ = io.ReadFull(crand.Reader, b)
	return base64.RawURLEncoding.EncodeToString(b)
}

func (f *Faker) IPv4Int64() int64 {
	val := f.IPv4()
	ip := net.ParseIP(val).To4()
	if ip == nil {
		return 0
	}
	return int64(ip[0])<<24 | int64(ip[1])<<16 | int64(ip[2])<<8 | int64(ip[3])
}

func (f *Faker) IPv4() string {
	return fmt.Sprintf("%d.%d.%d.%d",
		rand.Intn(256),
		rand.Intn(256),
		rand.Intn(256),
		rand.Intn(256),
	)
}
